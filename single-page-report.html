<html>
    <head>
        <script src="node_modules/powerbi-client/dist/powerbi.js"></script>
		<script src="lab.js"></script>
        <script type="text/javascript" src="https://alcdn.msauth.net/browser/2.35.0/js/msal-browser.min.js"></script>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            #exportDataBtn {
                display: block;
                margin: 10px 0;
                padding: 10px 20px;
                background: #0078d4;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
            }
            #exportDataBtn:disabled {
                background: #ccc;
                cursor: not-allowed;
            }
            #exportDataBtn:hover:not(:disabled) {
                background: #106ebe;
            }
            #embedContainer {
                width: 100%;
                height: calc(100vh - 120px);
                min-height: 600px;
                border: 1px solid #ddd;
            }
            #exportCurrentPageBtn {
                margin-left: 10px;
                padding: 10px 20px;
                background: #dc3545;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                position: relative;
            }
            #exportCurrentPageBtn:disabled {
                background: #ccc;
                cursor: not-allowed;
            }
            #exportCurrentPageBtn:hover:not(:disabled) {
                background: #c82333;
            }
            .spinner {
                display: inline-block;
                width: 14px;
                height: 14px;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-top-color: white;
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
                margin-right: 8px;
                vertical-align: middle;
            }
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            #exportStatus {
                margin-left: 10px;
                font-size: 14px;
                color: #666;
                font-style: italic;
            }
            #questionSection {
                margin: 20px 0;
                padding: 20px;
                background: #f5f5f5;
                border-radius: 8px;
            }
            #questionInput {
                width: 100%;
                padding: 10px;
                font-size: 14px;
                border: 1px solid #ddd;
                border-radius: 4px;
                margin-bottom: 10px;
            }
            #askQuestionBtn {
                padding: 10px 20px;
                background: #28a745;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
            }
            #askQuestionBtn:disabled {
                background: #ccc;
                cursor: not-allowed;
            }
            #askQuestionBtn:hover:not(:disabled) {
                background: #218838;
            }
            #answerSection {
                margin-top: 15px;
                padding: 15px;
                background: white;
                border-radius: 4px;
                border: 1px solid #ddd;
                min-height: 60px;
                max-height: 400px;
                overflow-y: auto;
                display: none;
            }
            #answerText {
                font-size: 14px;
                line-height: 1.6;
                color: #333;
            }
        </style>
    </head>
    <body>
        <h1>PowerBI Chat</h1>
        <div style="display: flex; align-items: center;">
            <button id="exportCurrentPageBtn" onclick="exportCurrentPage()" disabled>
                Export Current Page Data
            </button>
            <span id="exportStatus"></span>
        </div>
        
        <div id="questionSection">
            <h3>Ask a Question About the Data</h3>
            <input type="text" id="questionInput" placeholder="e.g., What is the most material source?" disabled>
            <button id="askQuestionBtn" onclick="askQuestion()" disabled>Ask Question</button>
            <div id="answerSection">
                <strong>Answer:</strong>
                <div id="answerText"></div>
            </div>
        </div>
        
        <div id="embedContainer"></div>
        <script>
            const scopes = [
                "https://analysis.windows.net/powerbi/api/Report.Read.All",
                "https://analysis.windows.net/powerbi/api/Dataset.Read.All"
            ];

            console.log("https://login.microsoftonline.com/" + pbilab.tenantId)

            const authConfig = {
                auth: {
                    authority: "https://login.microsoftonline.com/" + pbilab.tenantId,
                    clientId: pbilab.clientId,
                    redirectUri: window.location.origin + '/single-page-report.html'
                },
                cache: {
                    cacheLocation: "localStorage",
                    storeAuthStateInCookie: true
                },
            };

            const msalInstance = new msal.PublicClientApplication(authConfig);
            
            // Global variable to store the report instance
            let report;
            
            // Configuration for backend API
            const API_BASE_URL = 'http://localhost:8000'; // Update this to your backend URL
            
            // Store conversation history and current page hash
            let conversationHistory = [];
            let currentPageHash = null;
            
            function hashData(data) {
                // Create a simple hash from the page name and timestamp to detect data changes. We probably don't need the timestamp
                // unless there is another tab with the same name, which probably won't happen.
                const metadata = data?.reportMetadata || {};
                return `${metadata.pageName}_${metadata.extractionTimestamp}`;
            }

            function displayConversation(containerElement) {
                // Display the full conversation history (skip system messages)
                containerElement.innerHTML = '';
                
                conversationHistory.forEach((msg, index) => {
                    // Skip system messages (prompt and data context)
                    if (msg.role === 'system') {
                        return;
                    }
                    
                    const msgDiv = document.createElement('div');
                    msgDiv.style.marginBottom = '15px';
                    msgDiv.style.padding = '10px';
                    msgDiv.style.borderRadius = '8px';
                    
                    if (msg.role === 'user') {
                        msgDiv.style.backgroundColor = '#e3f2fd';
                        msgDiv.style.borderLeft = '4px solid #2196F3';
                        msgDiv.innerHTML = `<strong>You:</strong> ${msg.content}`;
                    } else {
                        msgDiv.style.backgroundColor = '#f1f8e9';
                        msgDiv.style.borderLeft = '4px solid #8bc34a';
                        msgDiv.innerHTML = `<strong>Assistant:</strong> ${msg.content}`;
                    }
                    
                    containerElement.appendChild(msgDiv);
                });
                
                // Scroll to bottom
                containerElement.scrollTop = containerElement.scrollHeight;
            }

            async function askQuestion() {
                const questionInput = document.getElementById('questionInput');
                const askButton = document.getElementById('askQuestionBtn');
                const answerSection = document.getElementById('answerSection');
                const answerText = document.getElementById('answerText');
                
                const question = questionInput.value.trim();
                
                if (!question) {
                    alert('Please enter a question');
                    return;
                }
                
                if (!window.currentPageData) {
                    alert('Please export the current page data first');
                    return;
                }
                
                // Check if data has changed (new page visited)
                const newPageHash = hashData(window.currentPageData);
                if (currentPageHash !== newPageHash) {
                    // Page changed - clear conversation history to start fresh and remove previous page data so a new conversation can start on the new page;
                    // we don't want to have data from a previous page interfering with the new page
                    const pageName = window.currentPageData?.reportMetadata?.pageName || 'Unknown';
                    console.log(`New page detected: "${pageName}" - clearing conversation history`);
                    conversationHistory = [];
                    currentPageHash = newPageHash;
                    
                    // Show visual indicator that conversation is starting fresh
                    answerSection.innerHTML = `<div style="text-align: center; color: #666; font-style: italic; padding: 10px;">Starting new conversation for page: "${pageName}"</div>`;
                    answerSection.style.display = 'block';
                    
                    // Clear after showing briefly
                    setTimeout(() => {
                        answerSection.innerHTML = '<div id="answerText"></div>';
                    }, 2000);
                }
                
                // If this is the first message (empty history), add PowerBI data as context
                if (conversationHistory.length === 0) {
                    // Format the PowerBI data for the LLM - ONLY include active visuals
                    const pageName = window.currentPageData?.reportMetadata?.pageName || 'Unknown';
                    const allVisuals = window.currentPageData?.visuals || [];
                    
                    // Filter to only active visuals (those visible in the current bookmark view)
                    const activeVisuals = allVisuals.filter(v => v.active !== false);
                    
                    console.log(`\n📤 Sending to LLM: ${activeVisuals.length} active visuals (${allVisuals.length - activeVisuals.length} inactive visuals filtered out)`);
                    
                    let dataContext = `PowerBI Report Page: '${pageName}'\n\n`;
                    activeVisuals.forEach((visual, i) => {
                        const title = visual.visualTitle || `Visual ${i + 1}`;
                        const type = visual.visualType || 'unknown';
                        const data = visual.data || '';
                        dataContext += `\n### ${title} (${type})\n\`\`\`\n${data}\n\`\`\`\n`;
                    });
                    
                    // Add data as a system message to conversation history
                    conversationHistory.push({
                        role: 'system',
                        content: `Here is the current PowerBI report data:\n\n${dataContext}`,
                        timestamp: new Date().toISOString()
                    });
                }
                
                // Add user's question to conversation history
                conversationHistory.push({
                    role: 'user',
                    content: question,
                    timestamp: new Date().toISOString()
                });
                
                // Show loading state
                askButton.disabled = true;
                askButton.innerHTML = '<span class="spinner"></span>Asking...';
                answerSection.style.display = 'block';
                answerText.textContent = 'Processing your question...';
                
                try {
                    const response = await fetch(`${API_BASE_URL}/ask`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            messages: conversationHistory,
                            data: window.currentPageData
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API returned ${response.status}: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    const answer = result.answer || 'No answer received';
                    
                    // Add assistant's response to conversation history
                    conversationHistory.push({
                        role: 'assistant',
                        content: answer,
                        timestamp: new Date().toISOString()
                    });
                    
                    // Re-get answerText in case the DOM was updated
                    const currentAnswerText = document.getElementById('answerText');
                    if (currentAnswerText) {
                        // Display the answer with conversation context
                        displayConversation(currentAnswerText);
                    }
                    
                    // Clear the input for next question
                    questionInput.value = '';
                    
                } catch (error) {
                    console.error('Error asking question:', error);
                    answerText.innerHTML = `<span style="color: #dc3545;">Error: ${error.message}. Make sure your backend API is running on ${API_BASE_URL}</span>`;
                } finally {
                    askButton.disabled = false;
                    askButton.innerHTML = 'Ask Question';
                }
            }

            async function exportCurrentPage() {
                if (!report) {
                    alert('Report not loaded yet. Please wait for the report to fully load.');
                    return;
                }

                // Show loading state
                const button = document.getElementById('exportCurrentPageBtn');
                const statusElement = document.getElementById('exportStatus');
                const originalButtonText = button.innerHTML;
                
                button.disabled = true;
                button.innerHTML = '<span class="spinner"></span>Exporting...';
                statusElement.textContent = 'Fetching page data...';

                try {
                    const pages = await report.getPages();
                    const activePage = pages.find(p => p.isActive);
                    
                    if (!activePage) {
                        button.innerHTML = originalButtonText;
                        button.disabled = false;
                        statusElement.textContent = '';
                        alert('No active page found!');
                        return;
                    }
                    
                    console.log(`Exporting from: "${activePage.displayName}"`);
                    
                    // Get bookmark information - I don't think this will actually be useful though
                    let activeBookmarks = [];
                    try {
                        const bookmarksManager = await report.bookmarksManager;
                        const bookmarks = await bookmarksManager.getBookmarks();

                        console.log(`Available bookmarks: ${bookmarks.length}`);
                        bookmarks.forEach(bookmark => {
                            console.log(`   - ${bookmark.displayName}`);
                        });
                    } catch (bookmarkError) {
                        console.log(`⚠️ Could not access bookmarks: ${bookmarkError.message}`);
                    }
                    
                    // Get current page filters and slicer state
                    let slicerStates = [];
                    try {
                        // Get page-level filters
                        const filters = await activePage.getFilters();
                        console.log(`\nPage Filters: ${filters.length}`);
                        filters.forEach(filter => {
                            console.log(`   - ${filter.target?.table}.${filter.target?.column}: ${filter.filterType}`);
                        });
                        
                        // Get slicers from the page - we'll need to dig more into what these really tell is and if we need them
                        const pageVisuals = await activePage.getVisuals();
                        const slicers = pageVisuals.filter(v => v.type === 'slicer');
                        console.log(`\nSlicers on page: ${slicers.length}`);
                        
                        for (const slicer of slicers) {
                            try {
                                const slicerState = await slicer.getSlicerState();
                                console.log(`   - ${slicer.title || slicer.name}: ${JSON.stringify(slicerState.filters)}`);
                                slicerStates.push({
                                    title: slicer.title,
                                    name: slicer.name,
                                    filters: slicerState.filters
                                });
                            } catch (err) {
                                console.log(`   - ${slicer.title || slicer.name}: Could not get state`);
                            }
                        }
                    } catch (filterError) {
                        console.log(`⚠️ Could not access filters: ${filterError.message}`);
                    }
                    
                    statusElement.textContent = `Analyzing visuals on "${activePage.displayName}"...`;
                    const visuals = await activePage.getVisuals();
                    console.log(`   Found ${visuals.length} visuals on this page`);
                    
                    // Detect active bookmark buttons (mode:1 = active, mode:0 = inactive)
                    // Not sure this really matters unless we tie the name of hte bookmark button to the corresponding section (i.e. look at
                    // the Process Understanding page and the "Source by preparar" bookmark button which shows the corresponding pivotTable of data below)
                    const activeBookmarkButtons = [];
                    console.log(`\nBookmark Button States:`);
                    for (const visual of visuals) {
                        if (visual.type === 'actionButton' && visual.title) {
                            const displayMode = visual.layout?.displayState?.mode;

                            // check if this button (bookmark) is active
                            if (displayMode === 1) {
                                console.log(`   ✅ ACTIVE: ${visual.title}`);
                                activeBookmarkButtons.push(visual.title);
                            } else if (displayMode === 0) {
                                console.log(`   ⚪ INACTIVE: ${visual.title}`);
                            }
                        }
                    }
                    
                    const pageData = {
                        pageName: activePage.displayName,
                        pageId: activePage.name,
                        visuals: []
                    };
                    
                    let skippedCount = 0;
                    let failedCount = 0;
                    
                    console.log(`    TABLES AND MATRICES:`);

                    for (let visualIndex = 0; visualIndex < visuals.length; visualIndex++) {
                        const visual = visuals[visualIndex];
                        
                        // Update status with progress
                        statusElement.textContent = `Exporting visual ${visualIndex + 1} of ${visuals.length}...`;
                        
                        // Skip non-exportable types
                        if (['slicer', 'textbox', 'shape', 'image', 'actionButton'].includes(visual.type)) {
                            skippedCount++;
                            continue;
                        }
                        
                        // Check if this visual is part of the active view
                        const visualName = visual.title || visual.name;
                        
                        // Check if visual is hidden (mode:1 = hidden, mode:0 = visible)
                        const isHidden = visual.layout?.displayState?.mode === 1;
                        const displayMode = visual.layout?.displayState?.mode;
                        
                        // Log export attempt for pivot tables and matrices to understand what we're seeing
                        if (visual.type === 'pivotTable' || visual.type === 'tableEx') {
                            const layout = visual.layout || {};
                            console.log(`      ${visual.title || visual.name} (${visual.type})`);
                            console.log(`         displayMode: ${displayMode} ${isHidden ? '[HIDDEN]' : '[VISIBLE]'}`);
                        }
                        
                        //if (isHidden) {
                        //    console.log(`      Skipping hidden visual: ${visual.title || visual.name}`);
                        //    skippedCount++;
                        //    continue;
                        //}
                        
                        try {
                            // Try to export data
                            let exportedData = null;
                            let exportMethod = null;
                            const models = window['powerbi-client'].models;
                            
                            try {
                                // try getting a summarized report first
                                exportedData = await visual.exportData(models.ExportDataType.Summarized);
                                exportMethod = 'Summarized';
                            } catch (err) {
                                console.log(`      Summarized failed: ${err.message}`);
                                try {
                                    // try getting the underlying export next
                                    exportedData = await visual.exportData(models.ExportDataType.Underlying);
                                    exportMethod = 'Underlying';
                                } catch (err2) {
                                    console.log(`      Underlying failed: ${err2.message}`);
                                    failedCount++;
                                    continue;
                                }
                            }
                            
                            if (exportedData && exportedData.data) {
                                const visualData = {
                                    visualType: visual.type,
                                    visualTitle: visual.title,
                                    visualName: visual.name,
                                    exportMethod: exportMethod,
                                    data: exportedData.data,
                                    rowCount: exportedData.data.split('\n').length,
                                    active: !isHidden  // If NOT hidden (visible), then it's active in current view
                                };
                                
                                // Log preview of exported data for verification
                                const activeLabel = !isHidden ? '✅ ACTIVE' : '⚪ INACTIVE';
                                console.log(`\n${activeLabel}: ${visual.title || visual.name}`);
                                console.log(`📄 Data preview (first 300 chars):`);
                                console.log(exportedData.data.substring(0, 300));
                                if (exportedData.data.length > 300) {
                                    console.log(`... (${exportedData.data.length} total characters, ${visualData.rowCount} rows)`);
                                }
                                
                                pageData.visuals.push(visualData);
                            } else {
                                console.log(`      Export returned null or empty data`);
                                failedCount++;
                            }
                        } catch (error) {
                            console.log(`      Exception: ${error.message}`);
                            failedCount++;
                        }
                    }
                    
                    console.log(`\n📊 Export Summary:`);
                    console.log(`   - Total visuals: ${visuals.length}`);
                    console.log(`   - Skipped (non-exportable types): ${skippedCount}`);
                    console.log(`   - Failed to export: ${failedCount}`);
                    console.log(`   - Successfully exported: ${pageData.visuals.length}`);
                    
                    console.log(`   📊 Collected ${pageData.visuals.length} visuals from this page`);
                    
                    // Organize the data
                    const finalData = {
                        reportMetadata: {
                            pageName: activePage.displayName,
                            extractionTimestamp: new Date().toISOString(),
                            slicers: slicerStates.length > 0 ? slicerStates : undefined,
                            activeBookmarkButtons: activeBookmarkButtons.length > 0 ? activeBookmarkButtons : undefined
                        },
                        visuals: pageData.visuals
                    };
                    
                    //window.currentPageData = finalData;
                    
                    // Get the data as plain JSON string
                    const jsonString = JSON.stringify(finalData, null, 2);
                    console.log(jsonString);
                    
                    // Show success message
                    statusElement.textContent = '✓ Data exported successfully';
                    statusElement.style.color = '#28a745';
                    
                    // Make data available globally for backend API calls
                    window.currentPageData = finalData;
                    
                    // Update the data hash to track this new page
                    currentDataHash = hashData(finalData);
                    
                    // Reset conversation history when new data is exported
                    conversationHistory = [];
                    document.getElementById('answerSection').style.display = 'none';
                    
                    // Enable the question input and button
                    document.getElementById('questionInput').disabled = false;
                    document.getElementById('askQuestionBtn').disabled = false;
                    
                    // Restore button after a short delay
                    setTimeout(() => {
                        button.innerHTML = originalButtonText;
                        button.disabled = false;
                        statusElement.textContent = '';
                        statusElement.style.color = '#666';
                    }, 3000);
                } catch (error) {
                    console.error('Error exporting current page:', error);
                    
                    // Restore button on error
                    button.innerHTML = originalButtonText;
                    button.disabled = false;
                    statusElement.textContent = '✗ Export failed - Check console';
                    statusElement.style.color = '#dc3545';
                    
                    setTimeout(() => {
                        statusElement.textContent = '';
                        statusElement.style.color = '#666';
                    }, 5000);
                    
                    alert('Error exporting current page. Check console for details.');
                }
            }

            async function doEmbed(token){

                let models = window['powerbi-client'].models;
                let reportId = pbilab.reportId;
                let config = {
                    accessToken: token,
                    embedUrl: "https://app.powerbi.com/reportEmbed?reportId=" + reportId,
                    id: reportId,
                    tokenType: models.TokenType.Aad,
                    type: 'report',
					permissions: models.Permissions.All,
					viewMode: models.ViewMode.View,
                };
                
                let container = document.getElementById('embedContainer');

				pbilab.pipeConfig(config);

                report = powerbi.embed(container, config);
                
                // Wait for the report to load before enabling data export
                report.on('loaded', function() {
                    console.log('Report loaded successfully');
                    document.getElementById('exportCurrentPageBtn').disabled = false;
                });
                
                // Disable button when page is changing, re-enable when rendering is complete
                report.on('pageChanged', function(event) {
                    console.log('Page changed to:', event.detail.newPage.displayName);
                    // Disable button while new page loads
                    document.getElementById('exportCurrentPageBtn').disabled = true;
                });
                
                // Re-enable button when page is fully rendered
                report.on('rendered', function() {
                    console.log('Page rendered successfully');
                    document.getElementById('exportCurrentPageBtn').disabled = false;
                });
                
                // Listen for bookmark button clicks to update active flags - this is the button even for when a bookmark is clicked.
                report.on('buttonClicked', async function(event) {
                    console.log('\nButton clicked:', event.detail);
                    
                    if (!window.currentPageData || !window.currentPageData.visuals) {
                        console.log('No data exported yet - skipping active flag update');
                        return;
                    }
                    
                    // Get the button title/name that was clicked
                    const buttonTitle = event.detail.title || event.detail.name;
                    console.log(`Button: "${buttonTitle}"`);
                    
                    // Update active flags in the stored data
                    let activatedCount = 0;
                    let deactivatedCount = 0;
                    
                    window.currentPageData.visuals.forEach(visual => {
                        const visualName = (visual.visualTitle || visual.visualName || '').toLowerCase();

                        // Only update visuals that appear to be bookmark-controlled
                        const isBookmarkControlled = visualName.includes('matrix') || visualName.includes('table');
                        
                        if (isBookmarkControlled) {
                            const wasActive = visual.active;
                            
                            if (visual.active && !wasActive) {
                                console.log(`   ✅ Activated: ${visual.visualTitle || visual.visualName}`);
                                activatedCount++;
                            } else if (!visual.active && wasActive) {
                                console.log(`   ⚪ Deactivated: ${visual.visualTitle || visual.visualName}`);
                                deactivatedCount++;
                            }
                        }
                    });
                    
                    // Update the metadata to reflect the new active bookmark button
                    if (window.currentPageData.reportMetadata) {
                        window.currentPageData.reportMetadata.activeBookmarkButtons = [buttonTitle];
                        window.currentPageData.reportMetadata.lastBookmarkClick = new Date().toISOString();
                    }
                });
                
                // Handle any errors
                report.on('error', function(event) {
                    console.error('Report error:', event.detail);
                });
				
				pbilab.bind(report);
            }

            async function doLogin(){
                const request = {
                    scopes: scopes,
					account: pbilab.userUpn,
                    redirectUri: window.location.origin + '/single-page-report.html'
                }

                let token = null;

                await msalInstance.handleRedirectPromise();

                try {
                    const loginResponse = await msalInstance.acquireTokenSilent(request);
                    token = loginResponse.accessToken;
                } catch (err) {
                    if (err) {
                        const loginResponse = await msalInstance.loginRedirect(request).catch(error => {
                            console.log(error);
                        });
                    } else {
                        console.log(err);
                    }
                }

                if(token){
                    doEmbed(token);
                }
            }

            doLogin();
            
        </script>
    </body>
</html>